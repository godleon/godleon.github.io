<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"godleon.github.io","root":"/blog/","scheme":"Muse","version":"8.0.0-rc.5","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false};
  </script>

  <meta name="description" content="本篇文章的主題圍繞在 Kubernetes 中的 Pod resource object，其中包含 Pod 的設計 &amp; 相關運作機制，並對這些概念做一些概略的介紹">
<meta property="og:type" content="article">
<meta property="og:title" content="[Kubernetes] Pod 的設計 &amp; 相關運作機制">
<meta property="og:url" content="https://godleon.github.io/blog/Kubernetes/k8s-Pod-Overview/index.html">
<meta property="og:site_name" content="小信豬的原始部落">
<meta property="og:description" content="本篇文章的主題圍繞在 Kubernetes 中的 Pod resource object，其中包含 Pod 的設計 &amp; 相關運作機制，並對這些概念做一些概略的介紹">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://godleon.github.io/blog/images/kubernetes/k8s_multi-containers-in-a-pod.png">
<meta property="og:image" content="https://godleon.github.io/blog/images/kubernetes/kubernetes-pod-life-cycle-status.jpg">
<meta property="article:published_time" content="2018-09-05T20:10:00.000Z">
<meta property="article:modified_time" content="2021-01-15T05:23:21.449Z">
<meta property="article:author" content="godleon">
<meta property="article:tag" content="Kubernetes">
<meta property="article:tag" content="CKA">
<meta property="article:tag" content="Kubernetes Core Concept">
<meta property="article:tag" content="CKA Core Concept">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://godleon.github.io/blog/images/kubernetes/k8s_multi-containers-in-a-pod.png">


<link rel="canonical" href="https://godleon.github.io/blog/Kubernetes/k8s-Pod-Overview/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>[Kubernetes] Pod 的設計 & 相關運作機制 | 小信豬的原始部落</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-703592-7"></script>
    <script data-pjax>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-703592-7');
      }
    </script>






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">小信豬的原始部落</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Overview"><span class="nav-number">1.</span> <span class="nav-text">Overview</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#What-is-Pod"><span class="nav-number">1.1.</span> <span class="nav-text">What is Pod ?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%96%AE%E7%8D%A8%E4%BD%BF%E7%94%A8-Pod-%E9%9C%80%E6%B3%A8%E6%84%8F%E7%9A%84%E4%BA%8B%E9%A0%85"><span class="nav-number">1.2.</span> <span class="nav-text">單獨使用 Pod 需注意的事項</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pod-amp-Controller"><span class="nav-number">1.3.</span> <span class="nav-text">Pod &amp; Controller</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A8%AD%E8%A8%88-Pod-%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">1.4.</span> <span class="nav-text">設計 Pod 的原因</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E4%BE%BF%E7%AE%A1%E7%90%86"><span class="nav-number">1.4.1.</span> <span class="nav-text">方便管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B3%87%E6%BA%90%E5%85%B1%E4%BA%AB-amp-%E9%80%9A%E8%A8%8A"><span class="nav-number">1.4.2.</span> <span class="nav-text">資源共享 &amp; 通訊</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B5%82%E6%AD%A2-Pod"><span class="nav-number">1.5.</span> <span class="nav-text">終止 Pod</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Privileged-Mode"><span class="nav-number">1.6.</span> <span class="nav-text">Privileged Mode</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Pod-Lifecycle"><span class="nav-number">2.</span> <span class="nav-text">Pod Lifecycle</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Pod-Phase"><span class="nav-number">2.1.</span> <span class="nav-text">Pod Phase</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pod-Condition"><span class="nav-number">2.2.</span> <span class="nav-text">Pod Condition</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A8%BA%E6%96%B7-Container-%E6%9C%89%E7%84%A1%E6%AD%A3%E5%B8%B8%E9%81%8B%E8%A1%8C-Probe"><span class="nav-number">2.3.</span> <span class="nav-text">診斷 Container 有無正常運行 - Probe</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#What-is-Probe"><span class="nav-number">2.3.1.</span> <span class="nav-text">What is Probe?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Probe-%E7%A8%AE%E9%A1%9E"><span class="nav-number">2.3.2.</span> <span class="nav-text">Probe 種類</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%95%E6%99%82%E4%BD%BF%E7%94%A8%E9%80%99%E4%BA%9B-Probe"><span class="nav-number">2.3.3.</span> <span class="nav-text">何時使用這些 Probe?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pod-readiness-gate"><span class="nav-number">2.4.</span> <span class="nav-text">Pod readiness gate</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Restart-Policy"><span class="nav-number">2.5.</span> <span class="nav-text">Restart Policy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pod-Lifetime"><span class="nav-number">2.6.</span> <span class="nav-text">Pod Lifetime</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pod-Status-Restart-Policy-%E7%9A%84%E6%83%85%E5%A2%83%E7%AF%84%E4%BE%8B"><span class="nav-number">2.7.</span> <span class="nav-text">Pod Status + Restart Policy 的情境範例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Init-Container"><span class="nav-number">3.</span> <span class="nav-text">Init Container</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#What-is-Init-Container"><span class="nav-number">3.1.</span> <span class="nav-text">What is Init Container ?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Init-Container-%E5%8F%AF%E4%BB%A5%E5%81%9A%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85"><span class="nav-number">3.2.</span> <span class="nav-text">Init Container 可以做哪些事情 ?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AF%84%E4%BE%8B%E8%AA%AA%E6%98%8E"><span class="nav-number">3.3.</span> <span class="nav-text">範例說明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%8A%E9%9C%80%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="nav-number">3.4.</span> <span class="nav-text">使用上需注意的地方</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Resource-%E7%AE%A1%E7%90%86"><span class="nav-number">3.5.</span> <span class="nav-text">Resource 管理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Pod-Preset"><span class="nav-number">4.</span> <span class="nav-text">Pod Preset</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#What-is-PodPreset"><span class="nav-number">4.1.</span> <span class="nav-text">What is PodPreset ?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PodPreset-%E6%98%AF%E5%A6%82%E4%BD%95%E9%81%8B%E4%BD%9C%E7%9A%84"><span class="nav-number">4.2.</span> <span class="nav-text">PodPreset 是如何運作的?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%95%9F%E7%94%A8-PodPreset"><span class="nav-number">4.3.</span> <span class="nav-text">如何啟用 PodPreset ?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%AF%84%E4%BE%8B"><span class="nav-number">4.4.</span> <span class="nav-text">使用範例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#References"><span class="nav-number">5.</span> <span class="nav-text">References</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">godleon</p>
  <div class="site-description" itemprop="description">把時間花在哪裡，成就就在哪裡</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives">
          <span class="site-state-item-count">151</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
        <span class="site-state-item-count">108</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://godleon.github.io/blog/Kubernetes/k8s-Pod-Overview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="godleon">
      <meta itemprop="description" content="把時間花在哪裡，成就就在哪裡">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小信豬的原始部落">
    </span>

    
    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          [Kubernetes] Pod 的設計 & 相關運作機制
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-09-06 04:10:00" itemprop="dateCreated datePublished" datetime="2018-09-06T04:10:00+08:00">2018-09-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-15 13:23:21" itemprop="dateModified" datetime="2021-01-15T13:23:21+08:00">2021-01-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Kubernetes/" itemprop="url" rel="index"><span itemprop="name">Kubernetes</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/blog/Kubernetes/k8s-Pod-Overview/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Kubernetes/k8s-Pod-Overview/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            <div class="post-description">本篇文章的主題圍繞在 Kubernetes 中的 Pod resource object，其中包含 Pod 的設計 & 相關運作機制，並對這些概念做一些概略的介紹</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><h2 id="What-is-Pod"><a href="#What-is-Pod" class="headerlink" title="What is Pod ?"></a>What is Pod ?</h2><p>Pod 是在 k8s 最基本的組成單位(也是最小的可佈署單位)，實際在 k8s 上運行的很多 resource object 都是以 pod 型式存在，因此了解 pod 運作的機制會讓我們對 k8s 有更深入的了解。</p>
<p>Pod 雖然是最基本的組成單位，但其實在設計上隱藏的相當多的細節，它封裝了許多不同的資源，也因此每個 pod 都有以下特性：</p>
<ul>
<li><p>包含一到多個 container</p>
</li>
<li><p>同一個 pod 都 container 都共享相同的檔案系統 &amp; volume … 等資源</p>
</li>
<li><p>container 共享相同的 network namespace(container 之間可以透過 <code>localhost</code> + <code>port number</code> 互相通訊)，且有獨一無二的 IP address</p>
</li>
<li><p>container 之間也可以透過進程間通信，例如：SystemV or POSIX shared memory</p>
</li>
<li><p>container 共享 pod 中的 volume resource</p>
</li>
<li><p>pod 中的 container 總是被同時調度 &amp; 有共同的運行環境</p>
</li>
</ul>
<blockquote>
<p>Pod 中共同的運行環境包含 Linux 的namespace，cgroup 和其他可能的隔絕環境，這部份跟 Docker container 是一樣的。不過在 pod 的環境中，每個 container 中可能還會因為 application 的管理策略會有不同的隔離方式</p>
</blockquote>
<p>Pod 在 k8s 中有兩種主要的使用方式：</p>
<ol>
<li><p>只運行一個 container: 這就類似在一個 container 外再包一個 wrapper</p>
</li>
<li><p>運行多個需要協同合作的 container: 這些 container 除了協同合作外，還共享相同的 network &amp; storage 資源，其它與 application 相關的資源可能會另外由一個 sidecar container 來負責處理</p>
</li>
</ol>
<blockquote>
<p>讓多個 container 同時運行在同一個 pod 裏面，算是比較進階的應用，除非確定有多個容器之間緊密合作的需求才考慮使用這樣的模式</p>
</blockquote>
<p>以下就是一個類似的應用範例：(一個 container 提供 web 服務，另一個則是負責 container management，從外面取得特定資料回來，並存到共享的 volume 中)</p>
<p><img src="/blog/images/kubernetes/k8s_multi-containers-in-a-pod.png" alt="Multiple Containers in a Pod"></p>
<h2 id="單獨使用-Pod-需注意的事項"><a href="#單獨使用-Pod-需注意的事項" class="headerlink" title="單獨使用 Pod 需注意的事項"></a>單獨使用 Pod 需注意的事項</h2><p>在 k8s 中直接使用獨立的 pod 是沒問題的，但並不建議這麼做，理由大概有以下幾個：</p>
<ul>
<li><p>獨立的 pod 若是發生問題時(例如: node failure)，k8s 不會協助恢復其正常的狀態</p>
</li>
<li><p>若 pod 所在的 worker node 因為資源不足或是進入維護狀態時，pod 不會被自動移到其他正常的 node 並重新啟動</p>
</li>
</ul>
<p>因此在 k8s 中，提供了一個更 high level 的抽象概念 <strong>controller</strong> 來處理上面的問題，而使用者在使用上也是應該透過這些 controller 來管理 pod。</p>
<h2 id="Pod-amp-Controller"><a href="#Pod-amp-Controller" class="headerlink" title="Pod &amp; Controller"></a>Pod &amp; Controller</h2><p>Controller 可以協助使用者完成以下的工作：</p>
<ul>
<li><p>建立 &amp; 管理多個 pod</p>
</li>
<li><p>replication 管理</p>
</li>
<li><p>rolling upgrade/rollback</p>
</li>
<li><p>self healing</p>
</li>
</ul>
<p>而在 k8s 中，屬於 controller 的 resource object 很多，詳細的清單可以參考<a href="https://godleon.github.io/blog/2018/08/31/Kubernetes/k8s-CoreConcept-ResourceObject-Overview/#Controller-%E9%A1%9E%E5%9E%8B%E7%9A%84-Resource-Object">此篇文章</a>。</p>
<p>基本上，controller 使用的是稱為 <strong>Pod Template</strong> 的資訊來管理 pod 相關的資源，而 pod template 其實就是整個 pod 的 spec 資訊，其中可能還包含了其他 resource object 的資訊，例如：ReplicationController, Jobs, DaemonSet … 等等。</p>
<h2 id="設計-Pod-的原因"><a href="#設計-Pod-的原因" class="headerlink" title="設計 Pod 的原因"></a>設計 Pod 的原因</h2><p>可能會有人想要知道，為什麼在 k8s 中不直接使用 <strong>Container</strong> 為單位而是用 <strong>Pod</strong> 呢? 主要有兩個原因：</p>
<h3 id="方便管理"><a href="#方便管理" class="headerlink" title="方便管理"></a>方便管理</h3><p>Pod 是由 <strong>multiple cooperating processes</strong> 這個 pattern 所產生出來的一種模型，將多個原本各自獨立的元素變成了一個緊密結合的服務單位，這種設計方式簡化了佈署佈署 &amp; 管理工作，並提供了一個 high level 的抽象概念來管理這些各自獨立的元素。</p>
<p>也因為設計 pod 作為 deployment unit，使得像是 <strong>Horizontal Scaling</strong>、<strong>Replication</strong>、<strong>Coordinated Replication</strong>、<strong>Resource Sharing</strong>、<strong>Dependency Management</strong> 這些功能在 k8s 中都可以自動被處理。</p>
<h3 id="資源共享-amp-通訊"><a href="#資源共享-amp-通訊" class="headerlink" title="資源共享 &amp; 通訊"></a>資源共享 &amp; 通訊</h3><p>如上面所提到的，透過 pod 的設計，讓同一個 pod 中的 container 可以很方便的共享 network &amp; volume 等 application 使用時相當重要的資源。</p>
<h2 id="終止-Pod"><a href="#終止-Pod" class="headerlink" title="終止 Pod"></a>終止 Pod</h2><p>在 k8s 中，當一個 pod 被指定要終止時，k8s 會儘量確保 container 可以優雅地按照正常的流程停止，沒必要不會直接送 <strong>SIGKILL</strong> 去清除對應的 process，以下是一個 pod 終止時的流程範例：</p>
<ol>
<li><p>使用者送出指令要刪除 pod，預設的寬限期(<strong>grace period</strong>)是 30 秒</p>
</li>
<li><p>超過寬限期後，pod 狀態在 API server 會被更新為 <strong>dead</strong></p>
</li>
<li><p>接著同步執行以下工作：</p>
<p> 3.1 此時若是在 CLI 中列出 pod，狀態會顯示 <strong>terminating</strong></p>
<p> 3.2 當 kubelet 發現 pod 被標記為 <strong>terminating</strong> 狀態時(目前尚在寬限期內)，開始停止 pod 的流程：</p>
<pre><code> 3.2.1 如果在pod中 定義了 [preStop hook](https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#hook-details)，此時會被呼叫；如果 preStop hook 在超過寬限期過後依然在運行，第二步會再增加 2 秒的寬限期

 3.2.2 向 Pod 中的 process 發送 **TERM** 信號；</code></pre>
<p> 3.3 該 Pod 會從 service 的 endpoint list 中移除，replication controller 不會再進行管理；此時若是有終止比較慢的 pod，也不會繼續處理 load balancer 轉發過來的流量</p>
</li>
<li><p>過了寬限期後，將會向 Pod 中還在運作的 process 發送 <strong>SIGKILL</strong> 來清除 process。</p>
</li>
<li><p>kublete 會在 API server 中設定 grace period 為 0，表示完成 pod 的刪工作已經完成。此時 Pod 已經在 在 API server 中消失，CLI 也無法看見</p>
</li>
</ol>
<p>預設的 grace period 為 30 秒，而使用 <code>kubectl delete</code> 指令可以直接透過 <code>--grace-period=&lt;seconds&gt;</code> 參數來改變這個預設值，若設定為 <strong>0</strong> 則是強制刪除 pod。</p>
<blockquote>
<p>在 v1.5 之後，若要使用 <code>--grace-period=0</code> 就必須要搭配 <code>--force</code> 參數一起使用</p>
</blockquote>
<p>另外，強制刪除 pod 會讓 API server 直接清除該 pod 的所有資訊，不會等待 kubelet 將 resource 清理完成，在使用上會有潛在的風險；這個功能若是要應用在 StatefulSet 中的 pod，建議參考<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/run-application/force-delete-stateful-set-pod/">官網文章 deleting Pods from a StatefulSet</a> 來處理。</p>
<h2 id="Privileged-Mode"><a href="#Privileged-Mode" class="headerlink" title="Privileged Mode"></a>Privileged Mode</h2><p>k8s v1.1 之後開始可以透過 pod spec 中的 <strong>SecurityContext</strong> 中的 <code>privileged</code> 屬性，讓 pod 以 privileged mode 的狀態下運行，如果使用者要透過 pod 操作 network stack or 存取特定裝置時相當好用；讓 container 中的 process 幾乎可以跟 container 外部的 process 有著幾乎相同的存取權限。</p>
<h1 id="Pod-Lifecycle"><a href="#Pod-Lifecycle" class="headerlink" title="Pod Lifecycle"></a>Pod Lifecycle</h1><p>Volume 跟 pod 有相同的生命週期(以 pod UID 為準)。當 Pod 因為某種原因被刪除或者被新創建但相同的 Pod 取代(UID 已經變更)，它相關的資源（例如：volume）也會被銷毀和再創建一個新的。</p>
<h2 id="Pod-Phase"><a href="#Pod-Phase" class="headerlink" title="Pod Phase"></a>Pod Phase</h2><p>當使用 <code>kubectl get pod</code> 命令嘗試取得目前 namespace 中的 pod 列表，可以看到列表中有個欄位為 <strong>STATUS</strong>，顯示著目前 pod 的狀態，而這個狀態資訊其實是一個名稱為 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.11/#podstatus-v1-core">PodStatus</a> 的物件中的 <strong>phase</strong> 欄位所提供，根據 pod 狀況不同會有以下的值：</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Pending</td>
<td>Pod 已被 Kubernetes 系統接受，但有一個或者多個 container image 尚未被建立完成。這一段時間包含了調度 Pod 的時間和通過網絡下載 image 的時間，需要一段時間來處理</td>
</tr>
<tr>
<td>Running</td>
<td>Pod 已經綁定到某個 node 上，相關的 container 都已經建立完成；且至少有個 container 正在運行 or 正處於 starting or restarting 的狀態下</td>
</tr>
<tr>
<td>Succeeded</td>
<td>Pod 中的所有 container 都被成功終止，並且不會再重啟</td>
</tr>
<tr>
<td>Failed</td>
<td>Pod 中的所有 container 都被終止，但至少有一個因為任務失敗而終止(表示退出時的狀態碼不為 0 or 被系統終止)</td>
</tr>
<tr>
<td>Unknown</td>
<td>因為某些原因無法取得 Pod 的狀態，通常是因為與 Pod 所在 node 通訊失敗</td>
</tr>
</tbody></table>
<p><img src="/blog/images/kubernetes/kubernetes-pod-life-cycle-status.jpg" alt="Pod Life Cycle"></p>
<h2 id="Pod-Condition"><a href="#Pod-Condition" class="headerlink" title="Pod Condition"></a>Pod Condition</h2><p>接著來看看 pod condition，以下透過 <code>kubectl describe pod/kubernetes-dashboard-xyz -n kube-system</code> 指令細部檢視 <strong>kubernetes-dashboard-xyz</strong> 這個 pod 的資訊可以看到類似一下內容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Name:               kubernetes-dashboard-xyz</span><br><span class="line">Namespace:          kube-system</span><br><span class="line">...(以下略)</span><br><span class="line">Conditions:</span><br><span class="line">  Type              Status</span><br><span class="line">  Initialized       True </span><br><span class="line">  Ready             True </span><br><span class="line">  ContainersReady   True </span><br><span class="line">  PodScheduled      True </span><br><span class="line">...(以下略)</span><br></pre></td></tr></table></figure>

<p>仔細看看在 Conditions 的部份，系統提供了我們上面這些資訊，代表的意義是：</p>
<ul>
<li><p><code>Initialized</code>: 所有的 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/">init container</a> 是否都有成功啟動</p>
</li>
<li><p><code>Ready</code>: 是否已經可接受 service request 或是可加入到 load balancer 中</p>
</li>
<li><p><code>ContainersReady</code>: 在 pod 中的所有 container 是否都已經 ready</p>
</li>
<li><p><code>PodScheduled</code>: pod 是否已經被 schedule 到特定的 node</p>
</li>
</ul>
<h2 id="診斷-Container-有無正常運行-Probe"><a href="#診斷-Container-有無正常運行-Probe" class="headerlink" title="診斷 Container 有無正常運行 - Probe"></a>診斷 Container 有無正常運行 - Probe</h2><h3 id="What-is-Probe"><a href="#What-is-Probe" class="headerlink" title="What is Probe?"></a>What is Probe?</h3><p>probe(探針)的設計目的在於定期診斷 container 是否持續正常運作中，由 kubelet 執行。而執行方式就是 kubelet 呼叫實作在 container 中的特定 <a target="_blank" rel="noopener" href="https://godoc.org/k8s.io/kubernetes/pkg/api/v1#Handler">handler</a> 來取得狀態資訊，目前 handler 可分為以下三類：</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.11/#execaction-v1-core">ExecAction</a>: 在 container 內執行特定命令。如果命令結束時 exit code 為 0 則視為診斷成功</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.11/#tcpsocketaction-v1-core">TCPSocketAction</a>: 對 pod 上的特定 port 進行 TCP check，若是 port 是 open 的狀態，則視為診斷成功</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.11/#httpgetaction-v1-core">HTTPGetAction</a>: 對指定的 pod IP+Port 執行 HTTP Get 請求。如果 HTTP response status code 大於等於200 且小於 400，則視為診斷成功</p>
</li>
</ol>
<p>當每個 probe 完成後，會有三種結果，分別是 <code>Success</code>(通過診斷)、<code>Failure</code>(未通過診斷) &amp; <code>Unknown</code>(診斷失敗 &amp; 不採取任何行動) </p>
<h3 id="Probe-種類"><a href="#Probe-種類" class="headerlink" title="Probe 種類"></a>Probe 種類</h3><p>目前 kubelet 可以根據使用者的設定，來執行以下兩種的 probe 並根據結果做出反應：</p>
<ul>
<li><code>livenessProbe</code>: 診斷 pod 是否處於 running 狀態。若診斷沒有通過，kueblet 就會殺掉 pod 並根據 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy">restart policy</a> 進行後續動作。此外，如果 pod spec 中沒有提供 livenessProbe 的設定，則預設為診斷成功。</li>
</ul>
<p>以下是一個 livenessProbe 的設定範例</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">test:</span> <span class="string">liveness</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">liveness-http</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">args:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/server</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">k8s.gcr.io/liveness</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="comment"># when &quot;host&quot; is not defined, &quot;PodIP&quot; will be used</span></span><br><span class="line">        <span class="comment"># host: my-host</span></span><br><span class="line">        <span class="comment"># when &quot;scheme&quot; is not defined, &quot;HTTP&quot; scheme will be used. Only &quot;HTTP&quot; and &quot;HTTPS&quot; are allowed</span></span><br><span class="line">        <span class="comment"># scheme: HTTPS</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/healthz</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">        <span class="attr">httpHeaders:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">X-Custom-Header</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">Awesome</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">15</span></span><br><span class="line">      <span class="attr">timeoutSeconds:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">liveness</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>readinessProbe</code>: 診斷 pod 是否可以接受 service request。若診斷沒有通過，與這個 pod 相關的 service endpoint 資訊都會被 controller 移除。在 initial delay 之前 readiness 狀態會被預設為 failure。此外，如果 pod spec 中沒有提供 readinessProbe 的設定，則預設為診斷成功。</li>
</ul>
<h3 id="何時使用這些-Probe"><a href="#何時使用這些-Probe" class="headerlink" title="何時使用這些 Probe?"></a>何時使用這些 Probe?</h3><p>使用 probe 大概有幾個原則可以遵循：</p>
<ul>
<li><p>如果 container 有設計成當遇到問題的時候會自己 crash，不會卡死，那就不用特別設定 livenessProbe，kubelet 會自動根據 restart policy 來進行後續處理</p>
</li>
<li><p>如果希望 pod 可以在 probe 診斷失敗的時候被 kill 並 restart，那就要把 <code>restartPolicy</code> 設定為 <strong>Always</strong> or <strong>OnFailure</strong></p>
</li>
<li><p>如果希望 pod 進入正常服務狀態的時候才開始接收 service request 的話，那就設定 <code>readinessProbe</code>，只有當診斷成功時，k8s 才會把 service request 送給 pod</p>
</li>
<li><p>若 container 啟動時需要處理大量資料 or 設定檔 or 進行 migration 的檢查，此時就需要設定 <code>readinessProbe</code>，當診斷成功後才開始接收 service request</p>
</li>
<li><p>如果只是要在 pod 刪除時不接收任何 service request，其實不需要設定任何的 probe</p>
</li>
</ul>
<h2 id="Pod-readiness-gate"><a href="#Pod-readiness-gate" class="headerlink" title="Pod readiness gate"></a>Pod readiness gate</h2><p>這是在 v1.11 後開始推出一個稱為 <strong><a target="_blank" rel="noopener" href="https://github.com/kubernetes/community/blob/master/keps/sig-network/0007-pod-ready%2B%2B.md">Pod ready++</a></strong> 的功能(在 v1.11 中還是 alpha)，目的是要透過開放讓額外的 feedback or signal 放到 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.11/#podstatus-v1-core">Pod Status</a> 中，來強化 Pod readiness 的診斷功能。</p>
<p>有了這個功能後，就可以在 pod spec 中定義要額外診斷的 <strong>status.conditions</strong>(預設值為 <code>False</code>)，而 pod condition 的定義必須是以 key/value 的型式，以下是一個範例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">readinessGates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">conditionType:</span> <span class="string">&quot;www.example.com/feature-1&quot;</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">conditions:</span></span><br><span class="line">    <span class="comment"># 內建的 pod condition 資訊</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Ready</span></span><br><span class="line">      <span class="attr">status:</span> <span class="string">&quot;True&quot;</span></span><br><span class="line">      <span class="attr">lastProbeTime:</span> <span class="literal">null</span></span><br><span class="line">      <span class="attr">lastTransitionTime:</span> <span class="number">2018-01-01T00:00:00Z</span></span><br><span class="line">    <span class="comment"># 額外的 pod condition 資訊</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">&quot;www.example.com/feature-1&quot;</span></span><br><span class="line">      <span class="attr">status:</span> <span class="string">&quot;False&quot;</span></span><br><span class="line">      <span class="attr">lastProbeTIme:</span> <span class="literal">null</span></span><br><span class="line">      <span class="attr">lastTransitionTime:</span> <span class="number">2018-01-01T00:00:00Z</span></span><br><span class="line">  <span class="attr">containerStatuses:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerID:</span> <span class="string">docker://abcd...</span></span><br><span class="line">      <span class="attr">ready:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<p>目前 <strong>kubectl patch</strong> 命令不支援變更 object status，所以要塞入額外的 pod condition 資訊必須使用 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/using-api/client-libraries/">k8s client library</a> 來完成。</p>
<p>因此有了 readinessGates 之後，只有在同時滿足以下兩個條件下，pod 才會被診斷為 ready：</p>
<ol>
<li><p>pod 中所有的 container 狀態皆為 Ready</p>
</li>
<li><p>所有在 pod spec 中定義的 ReadinessGates 的狀態皆為 True</p>
</li>
</ol>
<p>若要啟用這個功能，必須要在啟用 k8s 元件時，在 <strong><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/command-line-tools-reference/feature-gates/">–feature-gates</a></strong> 參數中把 <code>PodReadinessGates</code> 設定為 True。</p>
<h2 id="Restart-Policy"><a href="#Restart-Policy" class="headerlink" title="Restart Policy"></a>Restart Policy</h2><p>關於 restart policy 有幾個重點：</p>
<ul>
<li><p>有 <code>Always</code>(預設值), <code>OnFailure</code>, <code>Never</code> 三種不同的 restart policy</p>
</li>
<li><p>restart policy 套用的範圍是 pod 中的所有 container，而不是某一個</p>
</li>
<li><p>restart policy 僅會透過使用同一個 node 上的 kubelet 來重起 container</p>
</li>
<li><p>失敗的 container 會由 kubelet 重新啟動，但每次的延遲時間都會加長(10秒，20秒，40秒…)，延遲時間上限為 5 分鐘，並在 container 成功執行十分鐘後重置</p>
</li>
<li><p>一旦 pod 被綁定到特定的 node 後，就不會在綁定到另一個 node</p>
</li>
</ul>
<h2 id="Pod-Lifetime"><a href="#Pod-Lifetime" class="headerlink" title="Pod Lifetime"></a>Pod Lifetime</h2><p>一般來說，除非有使用者 or controller 介入，不然 pod 不會消失；而目前有三種手段可以來控制 pod 的存活：</p>
<ul>
<li><p>一次性的工作，使用 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/jobs/run-to-completion-finite-workloads/">Job</a> resource object　來處理</p>
<blockquote>
<p>務必記得使用 Job 時，<strong>restartPolicy</strong> 必須設定為 <code>OnFailure</code> or <code>Never</code></p>
</blockquote>
</li>
<li><p>若希望 pod 不要被意外終止，使用 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/">ReplicationController</a>, <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/">ReplicaSet</a> 或是 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">Deployment</a> 來確保 desired status 可以被維持</p>
<blockquote>
<p>ReplicationController 只有在 restartPolicy 設定為 <code>Always</code> 才會正常的運作</p>
</blockquote>
</li>
<li><p>若在每一台機器中都需要運行的 pod，使用 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/">DaemonSet</a></p>
</li>
</ul>
<p>總之，透過上面的 resource object 來控制 pod 的存活，不要單獨佈署 pod。</p>
<h2 id="Pod-Status-Restart-Policy-的情境範例"><a href="#Pod-Status-Restart-Policy-的情境範例" class="headerlink" title="Pod Status + Restart Policy 的情境範例"></a>Pod Status + Restart Policy 的情境範例</h2><p>這部份可以參考官網的 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#example-states">Pod - Example states</a> 文件，有列出相當多的情境範例可參考，了解在不同的情境下，k8s 會做出的反應。</p>
<h1 id="Init-Container"><a href="#Init-Container" class="headerlink" title="Init Container"></a>Init Container</h1><h2 id="What-is-Init-Container"><a href="#What-is-Init-Container" class="headerlink" title="What is Init Container ?"></a>What is Init Container ?</h2><p>Init Container 是用來指定在 app container 開始運行之前(<strong>此時 pod network &amp; volume 資源都已經初始化完成</strong>)啟動起來完成某些特定的工作之用，因此 Init Container 也可能包含一些 app container image 中所沒有的工具或是 script。</p>
<p>一個 Pod 中能夠包含多個 app container 同時運行，同時也可以有多個 init container 來處理在 app container 開始運行前需要完成的特殊工作，而在 init container 工作執行完成之前，pod 的狀態都會顯示為 <strong>Initializing</strong>。</p>
<p>init container 跟一般的 container 幾乎相同，除了以下幾點：</p>
<ul>
<li><p>init container 總是會執行到結束為止</p>
</li>
<li><p>若定義多個 init container，會依序一個一個執行，且必須等到前一個 init container 執行成功後，才會輪到下一個</p>
</li>
</ul>
<blockquote>
<p>如果任何一個 init container 工作執行失敗，k8s 就會重新啟動 pod 並再度啟動所有的 init container 繼續執行工作，除非 <strong>restartPolicy</strong> 設定為 <code>Never</code></p>
</blockquote>
<h2 id="Init-Container-可以做哪些事情"><a href="#Init-Container-可以做哪些事情" class="headerlink" title="Init Container 可以做哪些事情 ?"></a>Init Container 可以做哪些事情 ?</h2><p>由於 init container 跟 app container 使用的是不同的 container image，因此在使用上會有一些優點，例如：</p>
<ul>
<li><p>可以打包一些特殊的工具並執行，而這些工具 &amp; 工作內容可能因為安全性的關係而沒有放進 app container 中</p>
</li>
<li><p>也可以包含一些常用的工具(例如：sed, awk, python, dig … 等等)，而為了這些簡單工具再包一個 container image 很沒必要</p>
</li>
<li><p>將 application image 的 builder &amp; deployer 分開，bulder 可以根據 init &amp; app container 的需要建立不同的 image，而不是將所有東西都打包在同一個 image 中，因此 deployer 的工作就會相對單純點</p>
</li>
<li><p>由於同一個 pod 的 container 中，mount namespace 還是分開的，因此 init container 可以設計用來存取 app container 不能存取的 secret</p>
</li>
<li><p>可提供一些簡單的方式來阻止 or 延緩 app container 啟動，直到某些條件達成為止</p>
</li>
</ul>
<p>以下是一些使用情境的介紹：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 執行某個 shell command 直到 service 啟動為止</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..100&#125;; <span class="keyword">do</span> sleep 1; <span class="keyword">if</span> dig myservice; <span class="keyword">then</span> <span class="built_in">exit</span> 0; <span class="keyword">fi</span>; <span class="keyword">done</span>; <span class="built_in">exit</span> 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將這個 pod 註冊到遠端的 server</span></span><br><span class="line">curl -X POST http://<span class="variable">$MANAGEMENT_SERVICE_HOST</span>:<span class="variable">$MANAGEMENT_SERVICE_PORT</span>/register -d ‘instance=$(&lt;POD_NAME&gt;)&amp;ip=$(&lt;POD_IP&gt;)’</span><br><span class="line"></span><br><span class="line"><span class="comment"># 單純的等待一會兒</span></span><br><span class="line">sleep 60</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將某個 git repository 複製下來放到 volume 上</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 將 value(例如：POD_IP) 放到設定檔中，並執行特定的 template tool(例如：Jinja2) 來動態的產生給 app container 使用的設定檔</span></span><br></pre></td></tr></table></figure>


<h2 id="範例說明"><a href="#範例說明" class="headerlink" title="範例說明"></a>範例說明</h2><p>接著是一個簡單的使用範例參考：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp-pod</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;echo The app is running! &amp;&amp; sleep 3600&#x27;</span>]</span><br><span class="line">  <span class="attr">initContainers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">init-myservice</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;until nslookup myservice; do echo waiting for myservice; sleep 2; done;&#x27;</span>]</span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">init-mydb</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;until nslookup mydb; do echo waiting for mydb; sleep 2; done;&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>看到上述的範例可能有點模糊，不曉得要等待什麼 service，因此要搭配下面的 service 定義來看：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myservice</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">9376</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mydb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">9377</span></span><br></pre></td></tr></table></figure>

<p>如此一來就很清楚了，只要當 service 設定完成，nslookup 可以找到對應的 IP 後，在 init container 中的回圈就會跳出 &amp; 結束工作</p>
<p>更多的使用範例可以參考以下網址：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-initialization/#creating-a-pod-that-has-an-init-container">Configure Pod Initialization - Kubernetes</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.qikqiak.com/post/pod-init-container/">初始化容器-blog.qikqiak.com|阳明的博客|Kubernetes|Docker|Python|Golang|Cloud Native</a></p>
</li>
</ul>
<h2 id="使用上需注意的地方"><a href="#使用上需注意的地方" class="headerlink" title="使用上需注意的地方"></a>使用上需注意的地方</h2><ul>
<li><p>若要修改 init container 的設定，只能針對 image 的欄位進行修改，而且修改後會等同於 restart pod</p>
</li>
<li><p>因為 init container 可能會 restart, retired 或是 re-execute，因此在 init container 中的執行程式要確保達成 idempotent 的特性(重複執行會得到相同結果)</p>
</li>
<li><p>不支援 readiness probe</p>
</li>
<li><p>可透過 <strong>activeDeadlineSeconds</strong> &amp; <strong>livenessProbe</strong> 兩個方式來確保 init container 不會永遠的掛掉</p>
</li>
<li><p>init container 與 app container 不能設定相同的 name</p>
</li>
</ul>
<h2 id="Resource-管理"><a href="#Resource-管理" class="headerlink" title="Resource 管理"></a>Resource 管理</h2><p>若是使用者有設定 resource quota，init container 同樣也會受到影響，而資源限制的規則大概如下：</p>
<ul>
<li><p>init container 最上層的 resource request 就是有效的 <strong>init request/limit</strong></p>
</li>
<li><p>若 pod 的層級有設定有效的 request/limit，則優先權大於 app container request/limit 的總和 &amp; 有效的 init request/limit</p>
</li>
<li><p>scheduling 是根據有效的 request/limit 進行的，這表示 init container 可以用到所有 request/limit 所定義的資源 (因為此時 pod 還用不到任何資源)</p>
</li>
<li><p>pod 的 QoS tier 跟 init/app container 的 QoS tier 是相同的</p>
</li>
</ul>
<h1 id="Pod-Preset"><a href="#Pod-Preset" class="headerlink" title="Pod Preset"></a>Pod Preset</h1><h2 id="What-is-PodPreset"><a href="#What-is-PodPreset" class="headerlink" title="What is PodPreset ?"></a>What is PodPreset ?</h2><p>PodPreset 是個很有意思的 resource object，主要是用來在 pod 建立的時候，放入一些使用者自行額外定義的資訊，這些資訊可以是 <code>secret</code>, <code>volume</code>, <code>volume mount</code> 或是 <code>環境變數</code> …. 等等。</p>
<p>在什麼情況下需要使用 PodPreset 呢? 當你有一批透過相同 template 產生出來的 pod，但卻希望他們可以根據特定的資訊(例如：<strong>環境變數</strong>)來產生不一樣的行為時，就可以透過 <strong>PodPreset</strong> 搭配 <strong>label selector</strong> 將特定的資訊放到帶有特殊 key/value 的 label 的 pod 中。</p>
<h2 id="PodPreset-是如何運作的"><a href="#PodPreset-是如何運作的" class="headerlink" title="PodPreset 是如何運作的?"></a>PodPreset 是如何運作的?</h2><p>首先要知道，PodPreset 是 k8s <strong>admission controller</strong> 所提供的功能，因此要使用必須要在 kube-apiserver 啟動時把這個功能選項(<code>--enable-admission-plugins=PodPreset</code>)加入才會有，當此功能啟動後，k8s 就會在收到 pod creation request，運行以下流程：</p>
<ul>
<li><p>取得目前 namespace 中已經存在的 PodPreset</p>
</li>
<li><p>檢查是否有符合任何 PodPreset 中 label selector 的定義</p>
</li>
<li><p>若有符合的 PodPreset，就將 PodPreset 中定義的資訊合併到 pod 中</p>
</li>
<li><p>若是合併 PodPreset 資訊時發生錯誤，會拋出一個 merge error 並記錄，但並不影響 pod 的建立過程(只是沒包含 PodPreset 定義的資訊)</p>
</li>
<li><p>若成功，PodPreset 就會在 pod spec 中增加一筆 annotation 資訊，內容如下：</p>
<blockquote>
<p><strong>podpreset.admission.kubernetes.io/podpreset-&lt;pod-preset name&gt;: “&lt;resource version&gt;”</strong></p>
</blockquote>
</li>
</ul>
<p>由於 PodPreset 這個機制是搭配 label selector 完成的，因此 PodPreset 中定義的資訊可以同時套用到 0 個或多個 pod；反之多個 pod 也可以因為含有多個 label 而被多個 PodPreset 套用，因此兩者是多對多的關係。</p>
<p>最後還需要注意的是，若 PodPreset 中定義的資訊類型屬於 <strong>Env</strong>, <strong>EnvFrom</strong> 或是 <strong>VolumeMounts</strong>，則會被修改的是 container spec；但若是 <strong>Volume</strong>，則是 pod spec 被修改。</p>
<blockquote>
<p>PodPreset 對 init container 無效</p>
</blockquote>
<h2 id="如何啟用-PodPreset"><a href="#如何啟用-PodPreset" class="headerlink" title="如何啟用 PodPreset ?"></a>如何啟用 PodPreset ?</h2><p>要在 k8s cluster 啟動 PodPreset 的功能，需要在 <strong>kube-apiserver</strong> 啟動的參數中，額外加入兩組設定：()</p>
<ol>
<li><p><code>--runtime-config=xxx=true,yyy=true,zzz=true,settings.k8s.io/v1alpha1=true</code></p>
</li>
<li><p><code>--enable-admission-plugins=xxx,yyy,zzz,PodPreset</code></p>
</li>
</ol>
<p>接著就可以在需要使用此功能的 namespace 定義 PodPreset resource object 來使用了!</p>
<h2 id="使用範例"><a href="#使用範例" class="headerlink" title="使用範例"></a>使用範例</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/inject-data-application/podpreset/">Inject Information into Pods Using a PodPreset - Kubernetes</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.qikqiak.com/post/how-to-use-podpreset-in-kubernetes/">kubernetes PodPreset 的使用-blog.qikqiak.com|阳明的博客|Kubernetes|Docker|Python|Golang|Cloud Native</a></p>
</li>
</ul>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><p><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">Pod Overview - Kubernetes</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/pods/pod/">Pods - Kubernetes</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/">Pod Lifecycle - Kubernetes</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/">Init Containers - Kubernetes</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-initialization/#creating-a-pod-that-has-an-init-container">Configure Pod Initialization - Kubernetes</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.qikqiak.com/post/pod-init-container/">初始化容器-blog.qikqiak.com|阳明的博客|Kubernetes|Docker|Python|Golang|Cloud Native</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/pods/podpreset/">Pod Preset - Kubernetes</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/inject-data-application/podpreset/">Inject Information into Pods Using a PodPreset - Kubernetes</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.qikqiak.com/post/how-to-use-podpreset-in-kubernetes/">kubernetes PodPreset 的使用-blog.qikqiak.com|阳明的博客|Kubernetes|Docker|Python|Golang|Cloud Native</a></p>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/Kubernetes/" rel="tag"># Kubernetes</a>
              <a href="/blog/tags/CKA/" rel="tag"># CKA</a>
              <a href="/blog/tags/Kubernetes-Core-Concept/" rel="tag"># Kubernetes Core Concept</a>
              <a href="/blog/tags/CKA-Core-Concept/" rel="tag"># CKA Core Concept</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/blog/Kubernetes/k8s-CoreConcept-ResourceObject-Overview/" rel="prev" title="[Kubernetes] Resource Object 概觀">
                  <i class="fa fa-chevron-left"></i> [Kubernetes] Resource Object 概觀
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/blog/Kubernetes/k8s-ReplicaSet-Overview/" rel="next" title="[Kubernetes] ReplicaSet 介紹">
                  [Kubernetes] ReplicaSet 介紹 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  



      
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">godleon</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script>
<script src="/blog/js/utils.js"></script><script src="/blog/js/motion.js"></script><script src="/blog/js/schemes/muse.js"></script><script src="/blog/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  















  








    <div class="pjax">
  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://godleon-blog-hexo.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "https://godleon.github.io/blog/Kubernetes/k8s-Pod-Overview/";
    this.page.identifier = "Kubernetes/k8s-Pod-Overview/";
    this.page.title = "[Kubernetes] Pod 的設計 & 相關運作機制";
    };
  NexT.utils.loadComments('#disqus_thread', () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://godleon-blog-hexo.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

    </div>
</body>
</html>
